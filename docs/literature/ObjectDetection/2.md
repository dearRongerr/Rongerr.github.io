# ç›®æ ‡æ£€æµ‹åŸºç¡€çŸ¥è¯†

## IOU

### IOUæ˜¯ä»€ä¹ˆï¼Ÿ

æ–‡å­—ï¼šIntersection over Unionã€ä¸¤ä¸ªboxåŒºåŸŸçš„äº¤é›†æ¯”ä¸Šå¹¶é›†ã€äº¤å¹¶æ¯”

[å›¾ç¤º](https://zhuanlan.zhihu.com/p/54709759)ï¼š![image-20241126113242206](images/image-20241126113242206.png)

### IOUæ€ä¹ˆå®ç°ï¼Ÿ


æ€è·¯ï¼šï¼ˆæ³¨æ„ç»´åº¦ä¸€è‡´ï¼‰

- é¦–å…ˆè®¡ç®—ä¸¤ä¸ªboxå·¦ä¸Šè§’ç‚¹åæ ‡çš„æœ€å¤§å€¼å’Œå³ä¸‹è§’åæ ‡çš„æœ€å°å€¼ 

- ç„¶åè®¡ç®—äº¤é›†é¢ç§¯ 

- æœ€åæŠŠäº¤é›†é¢ç§¯é™¤ä»¥å¯¹åº”çš„å¹¶é›†é¢ç§¯

!!! note
	å·¦ä¸Šè§’åæ ‡å’Œå³ä¸‹è§’åæ ‡ç¡®å®šä¸€ä¸ªæ¡†



#### å®˜æ–¹api

![image-20241126114453538](images/image-20241126114453538.png)

![image-20241126114654034](images/image-20241126114654034.png)

  pytorchæºç ï¼š

ï¼ˆæ³¨æ„çŸ©é˜µç»´åº¦çš„å˜åŒ–ï¼‰

#### box_iou

```python
def box_iou(boxes1: Tensor, boxes2: Tensor) -> Tensor:
    """
    Return intersection-over-union (Jaccard index) between two sets of boxes.

    Both sets of boxes are expected to be in ``(x1, y1, x2, y2)`` format with
    ``0 <= x1 < x2`` and ``0 <= y1 < y2``.

    Args:
        boxes1 (Tensor[N, 4]): first set of boxes
        boxes2 (Tensor[M, 4]): second set of boxes

    Returns:
        Tensor[N, M]: the NxM matrix containing the pairwise IoU values for every element in boxes1 and boxes2
    """
    if not torch.jit.is_scripting() and not torch.jit.is_tracing():
        _log_api_usage_once(box_iou)
    inter, union = _box_inter_union(boxes1, boxes2)
    iou = inter / union
    return iou
```

**<u>æ‡‚äº†</u>**ï¼šboxes1æœ‰Nä¸ªï¼Œboxes2æœ‰Mä¸ªï¼Œè¿”å›çš„NÃ—Mæ˜¯boxes1ä¸­çš„æ‰€æœ‰æ£€æµ‹æ¡†ä¸boxes2ä¸­æ‰€æœ‰æ£€æµ‹æ¡†çš„IOUå€¼ï¼Œboxesï¼šé›†åˆã€æ¡†çš„é›†åˆ

#### _box_inter_union

```python
def _box_inter_union(boxes1: Tensor, boxes2: Tensor) -> Tuple[Tensor, Tensor]:
    area1 = box_area(boxes1) # (x1, y1, x2, y2)
    area2 = box_area(boxes2)

    lt = torch.max(boxes1[:, None, :2], boxes2[:, :2])  # [N,M,2] æ‰¾åˆ°å·¦ä¸Šè§’çš„æœ€å¤§å€¼
    rb = torch.min(boxes1[:, None, 2:], boxes2[:, 2:])  # [N,M,2] æ‰¾åˆ°å³ä¸‹è§’çš„æœ€å°å€¼

    wh = _upcast(rb - lt).clamp(min=0)  # [N,M,2]
    inter = wh[:, :, 0] * wh[:, :, 1]  # [N,M]

    union = area1[:, None] + area2 - inter

    return inter, union
```



#### box_area

**æ˜¯ä»€ä¹ˆï¼Ÿ**

ç»™å®šä¸€ç³»åˆ—è¾¹ç•Œæ¡†åæ ‡é›†åˆï¼Œè®¡ç®—æ¯ä¸ªè¾¹ç•Œæ¡†çš„é¢ç§¯  

**è¿”å›å€¼**ï¼šNçš„è¾¹ç•Œæ¡†çš„é¢ç§¯

**æ€ä¹ˆå®ç°çš„ï¼Ÿ** é¢ç§¯çš„è®¡ç®—å…¬å¼ï¼š`(boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])`

**è¾¹ç•Œæ¡†çš„åæ ‡é›†åˆï¼Ÿ** `(x1, y1, x2, y2)` 

```python
def box_area(boxes: Tensor) -> Tensor:
    """
    Computes the area of a set of bounding boxes, which are specified by their
    (x1, y1, x2, y2) coordinates.

    Args:
        boxes (Tensor[N, 4]): boxes for which the area will be computed. They
            are expected to be in (x1, y1, x2, y2) format with
            ``0 <= x1 < x2`` and ``0 <= y1 < y2``.

    Returns:
        Tensor[N]: the area for each box
    """
    if not torch.jit.is_scripting() and not torch.jit.is_tracing():
        _log_api_usage_once(box_area)
    boxes = _upcast(boxes)
    return (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])
```

#### [Reference  ä»£ç å®ç°](https://zhuanlan.zhihu.com/p/54709759)

![image-20241126124613097](images/image-20241126124613097.png)



```python
import torch
import matplotlib.pyplot as plt
import matplotlib.patches as patches

# IOUè®¡ç®—
# å‡è®¾box1ç»´åº¦ä¸º[N,4]   box2ç»´åº¦ä¸º[M,4]
def iou(box1, box2):
    N = box1.size(0)
    M = box2.size(0)

    lt = torch.max(  # å·¦ä¸Šè§’çš„ç‚¹
        box1[:, :2].unsqueeze(1).expand(N, M, 2),   # [N,2]->[N,1,2]->[N,M,2]
        box2[:, :2].unsqueeze(0).expand(N, M, 2),   # [M,2]->[1,M,2]->[N,M,2]
    )
    print("lt",lt)
    print("lt shape",lt.shape)

    rb = torch.min(
        box1[:, 2:].unsqueeze(1).expand(N, M, 2),
        box2[:, 2:].unsqueeze(0).expand(N, M, 2),
    )
    print("rb",rb)
    print("rb shape",rb.shape)

    wh = rb - lt  # [N,M,2]
    print("wh",wh)
    wh[wh < 0] = 0   # ä¸¤ä¸ªboxæ²¡æœ‰é‡å åŒºåŸŸ
    inter = wh[:,:,0] * wh[:,:,1]   # [N,M]

    area1 = (box1[:,2]-box1[:,0]) * (box1[:,3]-box1[:,1])  # (N,)
    area2 = (box2[:,2]-box2[:,0]) * (box2[:,3]-box2[:,1])  # (M,)
    area1 = area1.unsqueeze(1).expand(N,M)  # (N,M)
    area2 = area2.unsqueeze(0).expand(N,M)  # (N,M)

    iou = inter / (area1 + area2 - inter)
    return iou

# # æµ‹è¯•ä»£ç 1
# M=1
# N=1
# box1 = torch.tensor([[20, 30, 40, 50]], dtype=torch.float)  # æ‰‹åŠ¨è®¾ç½®æœ‰é‡å åŒºåŸŸçš„æ¡†
# box2 = torch.tensor([[30, 40, 50, 60]], dtype=torch.float)
# # IOU: tensor([[0.1429]])

# æµ‹è¯•ä»£ç 2
M=2
N=1
box1 = torch.tensor([[20, 30, 40, 50]], dtype=torch.float)  # æ‰‹åŠ¨è®¾ç½®æœ‰é‡å åŒºåŸŸçš„æ¡†
print(box1.shape)
box2 = torch.tensor([[30, 40, 50, 60], [15, 25, 35, 45]], dtype=torch.float)
print(box2.shape)

# IOU: tensor([[0.1429, 0.3913]])

# æµ‹è¯•ä»£ç 3
# N=2
# M=3
# box1 = torch.tensor([[20, 30, 40, 50], [60, 70, 80, 90]], dtype=torch.float)  # æ‰‹åŠ¨è®¾ç½®æœ‰é‡å åŒºåŸŸçš„æ¡†
# print(box1.shape)
# box2 = torch.tensor([[30, 40, 50, 60], [70, 80, 90, 100], [15, 25, 35, 45]], dtype=torch.float)
# print(box2.shape)

# print("Box1:", box1)
# print("Box2:", box2)
# print("IOU:", iou(box1, box2))

# # ç»˜åˆ¶è¾¹ç•Œæ¡†
# fig, ax = plt.subplots(1)

# # ç»˜åˆ¶box1
# for i in range(N):
#     rect = patches.Rectangle((box1[i, 0], box1[i, 1]), box1[i, 2] - box1[i, 0], box1[i, 3] - box1[i, 1], linewidth=1, edgecolor='r', facecolor='none')
#     ax.add_patch(rect)

# # ç»˜åˆ¶box2
# for i in range(M):
#     rect = patches.Rectangle((box2[i, 0], box2[i, 1]), box2[i, 2] - box2[i, 0], box2[i, 3] - box2[i, 1], linewidth=1, edgecolor='b', facecolor='none')
#     ax.add_patch(rect)

# plt.xlim(0, 100)
# plt.ylim(0, 100)
# plt.gca().set_aspect('equal', adjustable='box')
# plt.show()
```

å…¶ä¸­ï¼š

torch.unsqueeze(1) è¡¨ç¤ºå¢åŠ ä¸€ä¸ªç»´åº¦ï¼Œå¢åŠ ä½ç½®ä¸ºç»´åº¦1

torch.squeeze(1) è¡¨ç¤ºå‡å°‘ä¸€ä¸ªç»´åº¦

ğŸŒ°ï¼š

![image-20241126141029848](images/image-20241126141029848.png)

$\frac{1}{7}$



## NMS

### NMSæ˜¯ä»€ä¹ˆï¼Ÿ

5ä¸ªå­—ï¼šè¿‡æ»¤å†—ä½™æ¡†

> æ–‡å­—æè¿°ã€æ•°å­¦å®ä¾‹

æ–‡å­—ï¼š

- Non-maximum suppressionã€éæå¤§å€¼æŠ‘åˆ¶ç®—æ³•

[æ•°å­¦å®ä¾‹](https://zhuanlan.zhihu.com/p/60794316)

[å›¾ç¤º](https://blog.csdn.net/m0_56569131/article/details/136192324)ï¼š

éœ€è¦ç»™å®šçš„è¾“å…¥ï¼šé¢„æµ‹çš„è¾¹ç•Œæ¡†åŠç½®ä¿¡åº¦

!!! note  
    éæå¤§å€¼æŠ‘åˆ¶ï¼ˆNMSï¼‰ç®—æ³•ï¼Œç”¨äºå»é™¤é‡å çš„è¾¹ç•Œæ¡†     
    :param bboxes: è¾¹ç•Œæ¡†åˆ—è¡¨ï¼Œæ¯ä¸ªè¾¹ç•Œæ¡†æ ¼å¼ä¸º[xmin, ymin, xmax, ymax]      
    :param scores: è¾¹ç•Œæ¡†å¯¹åº”çš„ç½®ä¿¡åº¦åˆ—è¡¨    
    :param iou _thresh: IOUï¼ˆäº¤å¹¶æ¯”ï¼‰é˜ˆå€¼ï¼Œç”¨äºåˆ¤æ–­ä¸¤ä¸ªè¾¹ç•Œæ¡†æ˜¯å¦é‡å                  
    :return: ç»è¿‡NMSå¤„ç†åçš„è¾¹ç•Œæ¡†å’Œç½®ä¿¡åº¦åˆ—è¡¨


![image-20241126144123636](images/image-20241126144123636.png)



### ä¸ºä»€ä¹ˆNMSï¼Ÿ

NMSçš„ä½œç”¨æ˜¯å»é™¤å¤šä¸ªé¢„æµ‹åŒä¸€ç‰©ä½“çš„å†—ä½™æ£€æµ‹æ¡†

**å“ªé‡Œéœ€è¦ç”¨ï¼Ÿ**

ä»¥RCNNç³»åˆ—ã€Yoloç³»åˆ—ä¸ºé¦–çš„ä¸€äº›æ¨¡å‹åœ¨ç›®æ ‡æ£€æµ‹é¢†åŸŸå·²ç»å–å¾—äº†éå¸¸æˆç†Ÿçš„åº”ç”¨æ•ˆæœï¼Œä½†ä¸ç®¡æ˜¯å•é˜¶æ®µæ¨¡å‹ï¼ˆå¦‚Yoloã€SSDï¼‰è¿˜æ˜¯ä¸¤é˜¶æ®µæ¨¡å‹ï¼ˆå¦‚RCNNï¼‰ï¼Œéƒ½éœ€è¦è¿›è¡Œéæå¤§å€¼æŠ‘åˆ¶ï¼ˆNon-Maximum Suppressionï¼Œç®€ç§°NMSï¼‰çš„åå¤„ç†æ“ä½œã€‚

**ç¼ºç‚¹**

â‘  O(n)çš„ç®—æ³•ï¼Œå½“æ¡†å¾ˆå¤šæ—¶ï¼Œæ¯”è¾ƒè´¹æ—¶ï¼›

â‘¡ åœ¨è¿›è¡ŒNMSæ—¶ï¼Œå¹¶æ²¡æœ‰ä½¿ç”¨åˆ°å›¾åƒç‰¹å¾ï¼Œè€Œæ˜¯ä»…ä»…ä½¿ç”¨äº†é¢„æµ‹æ¡†çš„å‚æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒNMSç®—æ³•æ˜¯æ²¡æœ‰â€œçœ‹åˆ°â€å›¾åƒçš„ï¼Œè¿™å°±ä¼šå¯¼è‡´ä¸€ä¸ªé—®é¢˜ï¼Œæœ‰äº›ç¦»å¾—éå¸¸è¿‘ç”šè‡³é‡åˆçš„ç‰©ä½“ï¼ˆæ¯”å¦‚äººç¾¤ä¸­çš„ä¸¤ä¸ªäººï¼‰å¯¹åº”çš„æ£€æµ‹æ¡†ä¼šè¢«NMSç®—æ³•ç»™å»é™¤æ‰è€Œåªä¿ç•™ä¸€ä¸ªï¼Œè¿™æ˜¯å› ä¸ºNMSç®—æ³•æ²¡æœ‰â€œçœ‹åˆ°â€œå›¾ç‰‡ï¼Œå¹¶ä¸çŸ¥é“è¿™é‡Œé¢æœ‰ä¸¤ä¸ªäººï¼ŒåªçŸ¥é“ä¸¤ä¸ªæ¡†çš„IoUï¼ˆintersection over unionï¼‰éå¸¸å¤§è€Œå·²ï¼›

â‘¢ NMSéœ€è¦è®¾ç½®è¶…å‚æ•°é˜ˆå€¼ï¼Œè¿™éœ€è¦ä¸€å®šçš„å…ˆéªŒçŸ¥è¯†ï¼Œè€Œä¸”åœ¨è®¾è®¡æ—¶ä¼šæ ¹æ®ä¸åŒçš„ä»»åŠ¡case by caseï¼Œè¿™ä½¿å¾—æ–¹æ³•ä¸å¤Ÿgeneral

**ä¸ºä»€ä¹ˆä¼šæœ‰å†—ä½™æ¡†ï¼Ÿ**

ä¸»è¦çš„åŸå› ï¼šåœ¨å¯¹æ¯ä¸ªanchorè¿›è¡Œå›å½’çš„æ—¶å€™ï¼Œæ˜¯ç‹¬ç«‹è¿›è¡Œçš„ã€‚

ä¹Ÿå°±æ˜¯è¯´ï¼Œå‡è®¾anchor Aå’Œanchor Bé¢„æµ‹çš„æ˜¯åŒä¸€ä¸ªäººï¼Œç„¶è€Œanchor Aå’Œanchor Bä¹‹é—´å¹¶æ²¡æœ‰ä¿¡æ¯äº¤æ¢ï¼Œå› æ­¤å®ƒä»¬ä¼šåˆ†åˆ«é¢„æµ‹å‡ºç›¸ä¼¼çš„ç»“æœï¼ˆç”šè‡³å¯èƒ½ç½®ä¿¡åˆ†æ•°éƒ½å¾ˆé«˜ï¼‰ã€‚å› æ­¤ï¼Œå¦‚æœèƒ½å¤Ÿè®©anchor BçŸ¥é“ï¼Œå·²ç»æœ‰anchor Aåœ¨é¢„æµ‹è¿™ä¸ªç‰©ä½“äº†ï¼Œå°±å¯ä»¥é¿å…anchor Bå»é¢„æµ‹é‡å¤çš„å†—ä½™æ¡†äº†ã€‚

### NMSæ€ä¹ˆå®ç°ï¼Ÿ

> ä»£ç 

#### å®˜æ–¹api

![image-20241126141513223](images/image-20241126141513223.png)

![image-20241126141452536](images/image-20241126141452536.png)

source

![image-20241126141556478](images/image-20241126141556478.png)

æˆ‘æ‰’ä¸åˆ°æºç 

#### ä»£ç å®ç°

1. é€‰å–è¿™ç±»boxä¸­scoresæœ€å¤§çš„å“ªä¸€ä¸ªï¼Œè®°ä¸ºbox_bestï¼Œå¹¶ä¿ç•™å®ƒ

2. è®¡ç®—box_bestä¸å…¶ä½™çš„boxçš„IOU

3. å¦‚æœå…¶IOU>0.5äº†ï¼Œé‚£ä¹ˆå°±èˆå¼ƒè¿™ä¸ªbox

   ï¼ˆç”±äºå¯èƒ½è¿™ä¸¤ä¸ªboxè¡¨ç¤ºåŒä¸€ç›®æ ‡ï¼Œæ‰€ä»¥ä¿ç•™åˆ†æ•°é«˜çš„å“ªä¸€ä¸ªï¼‰

4. ä»æœ€åå‰©ä½™çš„boxesä¸­ï¼Œå†æ‰¾å‡ºæœ€å¤§scoresçš„å“ªä¸€ä¸ªï¼Œå¦‚æ­¤å¾ªç¯å¾€å¤

![image-20241126143624696](images/image-20241126143624696.png)

```python
import torch
import matplotlib.pyplot as plt
import matplotlib.patches as patches

# NMSç®—æ³•
# bboxesç»´åº¦ä¸º[N,4]ï¼Œscoresç»´åº¦ä¸º[N,], å‡ä¸ºtensor
def nms(bboxes, scores, threshold=0.5):
    x1 = bboxes[:,0]
    y1 = bboxes[:,1]
    x2 = bboxes[:,2]
    y2 = bboxes[:,3]
    areas = (x2-x1)*(y2-y1)   # [N,] æ¯ä¸ªbboxçš„é¢ç§¯
    _, order = scores.sort(0, descending=True)    # é™åºæ’åˆ—

    keep = []
    while order.numel() > 0:       # torch.numel()è¿”å›å¼ é‡å…ƒç´ ä¸ªæ•°
        if order.numel() == 1:     # ä¿ç•™æ¡†åªå‰©ä¸€ä¸ª
            i = order.item()
            keep.append(i)
            break
        else:
            i = order[0].item()    # ä¿ç•™scoresæœ€å¤§çš„é‚£ä¸ªæ¡†box[i]
            keep.append(i)

        # è®¡ç®—box[i]ä¸å…¶ä½™å„æ¡†çš„IOU(æ€è·¯å¾ˆå¥½)
        xx1 = x1[order[1:]].clamp(min=x1[i])   # [N-1,]
        yy1 = y1[order[1:]].clamp(min=y1[i])
        xx2 = x2[order[1:]].clamp(max=x2[i])
        yy2 = y2[order[1:]].clamp(max=y2[i])
        inter = (xx2-xx1).clamp(min=0) * (yy2-yy1).clamp(min=0)   # [N-1,]

        iou = inter / (areas[i]+areas[order[1:]]-inter)  # [N-1,]
        idx = (iou <= threshold).nonzero().squeeze() # æ³¨æ„æ­¤æ—¶idxä¸º[N-1,] è€Œorderä¸º[N,]
        if idx.numel() == 0:
            break
        order = order[idx+1]  # ä¿®è¡¥ç´¢å¼•ä¹‹é—´çš„å·®å€¼
    return torch.LongTensor(keep)   # Pytorchçš„ç´¢å¼•å€¼ä¸ºLongTensor

# æµ‹è¯•ä»£ç 
bboxes = torch.tensor([
    [20, 30, 40, 50],
    [22, 32, 42, 52],
    [100, 100, 120, 130]
], dtype=torch.float)

scores = torch.tensor([0.9, 0.75, 0.6], dtype=torch.float)

# è°ƒç”¨NMSå‡½æ•°
keep_indices = nms(bboxes, scores, threshold=0.5)
print("ä¿ç•™çš„æ¡†ç´¢å¼•:", keep_indices)

# # å¯è§†åŒ–ç»“æœ
# fig, ax = plt.subplots(1)

# # ç»˜åˆ¶æ‰€æœ‰è¾¹ç•Œæ¡†
# for i in range(bboxes.size(0)):
#     rect = patches.Rectangle((bboxes[i, 0], bboxes[i, 1]), bboxes[i, 2] - bboxes[i, 0], bboxes[i, 3] - bboxes[i, 1], linewidth=1, edgecolor='r', facecolor='none', label='All Boxes' if i == 0 else "")
#     ax.add_patch(rect)

# # ç»˜åˆ¶ä¿ç•™çš„è¾¹ç•Œæ¡†
# for i in keep_indices:
#     rect = patches.Rectangle((bboxes[i, 0], bboxes[i, 1]), bboxes[i, 2] - bboxes[i, 0], bboxes[i, 3] - bboxes[i, 1], linewidth=2, edgecolor='b', facecolor='none', label='Kept Boxes' if i == keep_indices[0] else "")
#     ax.add_patch(rect)

# # æ·»åŠ å›¾ä¾‹
# handles, labels = ax.get_legend_handles_labels()
# by_label = dict(zip(labels, handles))
# ax.legend(by_label.values(), by_label.keys())

# plt.xlim(0, 150)
# plt.ylim(0, 150)
# plt.gca().set_aspect('equal', adjustable='box')
# plt.show()
```

torch.numel() è¡¨ç¤ºä¸€ä¸ªå¼ é‡æ€»å…ƒç´ çš„ä¸ªæ•°   

torch.clamp(min, max) è®¾ç½®ä¸Šä¸‹é™

tensor.item() æŠŠtensorå…ƒç´ å–å‡ºä½œä¸ºnumpyæ•°å­—

[å¦è¡¥å……ä»£ç ç¤ºä¾‹](https://blog.csdn.net/m0_56569131/article/details/136192324)

## Bounding box regression





## Anchor